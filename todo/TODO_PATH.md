
## 3. follow-service
- подписка на пользователя
- отписка

```java
public class Follow {
    private UUID followerId;
    private UUID followeeId;
    private LocalDateTime createdAt;
}
```

## 4. timeline-service
генерация ленты пользователя из бд по подпискам

## 5. api-gateway


## Future
- добавить логирование изменений сущностей с использоватем JPA (Hibernate)
- правильный подход для работы с ролями и статусами пользователя
- узнать что такое openTelemetry и подключить его (собирать все логи в 1 точку opentelemetry, zipkin, elk)
- твиты в монго
- твиты в касандра
- Neo4j для подписки в follow-service
- лайки в follow-service (отдельная таблица)
- spring-security в api-gateway
- spring-gateway в api-gateway
- ретвиты (отдельная таблица)
- redis с ttl для популярных твитов
- Kafka для асинхронной доставки твитов подписчикам (push timeline). (TimelineService получает событие → обновляет timeline подписчиков в Redis (push model))
- Shard DB по userId для твитов
- Поиск твитов → ElasticSearch.
- Rate limiting → предотвратить спам. (api-gateway)
- (профили, регистрации, аутентификация) в users-api
- Redis для профилей пользователей
- сервис уведомлений (с кафкой)
- Используем Hadoop HDFS или S3 для хранения архивов твитов, которые не нужны в реальном времени.
- Используем S3 для хранения архивов твитов, которые не нужны в реальном времени.
- Мониторинг и логирование: Используем Prometheus/Grafana для метрик и ELK Stack (Elasticsearch, Logstash, Kibana) для агрегации логов.
- Поэкспериминтировать с настройкой spring.jpa.open0in-view (https://www.youtube.com/watch?v=gBLyiBOc_Cg&t=2225s)
- Добавить кастомные метрики
- метрики производительности операций
- Внедрить rate limiting
- Усилить валидацию паролей
- Добавить кэширование
- Оптимизировать запросы (Добавить индексы в БД)
- Настроить алерты
- Добавить контрактные тесты
- N+1 проблема в фильтрации
- Добавить фильтрацию по дате создания пользователя
- Добавить аудит для пользователей
- проверить как   tracing:  sampling:  probability: 1.0 влияет на производительность
- сделать так чтобы в url не было id пользователя (для секурити)
- проработать ускорение билда докеробразов сервисов
- доработать existsUser, чтобы он возвращал false, если пользователь удален 
- добавить проверку на @NotNull для входных параметров в контроллере с @Validated над контроллером
- попробовать gRPC для обмена данными между сервисами
- попробовать прикрутить в gateway GraphQL
- поиграть с recon и версионированием api
- разобраться как лучше работать с сохранение и отображением времени. учесть город пользователя и маппинг времени из бд под него в ответах
- добавить комментарии постов
- добавить обновление комментариев в реал тайме
- добавить систему хэштэгов
- заменить feign client на http interfaces
- написать тесты для перформанса на JMH benchmark (https://github.com/hibernate/beanvalidation-benchmark/blob/451727417cf64d7e55efcfd5e98631841a567c13/README.md , https://github.com/hibernate/hibernate-validator/blob/main/performance/README.md , https://habr.com/ru/companies/spring_aio/articles/975422/)
- разобраться как собираться конкретный образ из докер компосе и сделать так чтобы он участвовал в докер компос
- сделать для лайков статус и мягкое удаление
- мягкое удаление подписки
- переделать фильтрацию подписок по логину с join (может вынести сущности User и Follow в common и прописать зависимости)