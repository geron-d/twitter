# Промпт для создания плана решения задачи

## Задача

Думай очень глубоко и многослойно. Не ограничивайся поверхностными ответами.
При каждом шаге анализа проверяй себя вопросами "почему?" и "а что если?". Ищи скрытые зависимости, потенциальные подводные камни и нетривиальные сценарии.

**ВАЖНО: Не пиши код на этом этапе. Только анализ и планирование.**

## Анализ задачи

1. Проанализируй задачу / сервис.
2. Опиши назначение, основные входные и выходные данные.
3. Выдели ключевые компоненты, которые нужно реализовать или изменить.
4. Укажи возможные риски, узкие места и зависимости.
5. Определи, какие стандарты проекта будут затронуты:
   - Код (STANDART_CODE.md)
   - Проект (STANDART_PROJECT.md)
   - Тесты (STANDART_TEST.md)
   - JavaDoc (STANDART_JAVADOC.md)
   - Swagger/OpenAPI (STANDART_SWAGGER.md)
   - README (STANDART_README.md)
   - Postman (STANDART_POSTMAN.md)
   - Docker (STANDART_DOCKER.md)

## Составление плана

Составь пошаговый план выполнения задачи, **разбивая реализацию по эндпоинтам**, а не только по слоям.

**ВАЖНО:** Если задача включает несколько эндпоинтов, план должен быть структурирован следующим образом:
1. Сначала - общая инфраструктура (Entity, Repository, общие DTO, Mapper интерфейс, Validator интерфейс, Service интерфейс, конфиги)
2. Затем - для каждого эндпоинта отдельно: все слои от DTO до тестов
3. В конце - финальная инфраструктура (README, Postman, проверка стандартов), которую можно написать только имея готовый рабочий код

### 1. Анализ и проектирование
- Анализ требований и существующего кода
- Проектирование API (если добавляются новые эндпоинты)
  - **Определить список всех эндпоинтов**, которые нужно реализовать
  - Для каждого эндпоинта определить: HTTP метод, путь, входные/выходные данные, валидацию, бизнес-правила
- Проектирование структуры данных (DTO, Entity)
- Определение зависимостей между компонентами
- Определение общих компонентов (Entity, Repository, общие DTO) и специфичных для эндпоинтов

### 2. Реализация инфраструктуры и конфигов
**Этот этап выполняется один раз для всех эндпоинтов.**

**Обязательно учитывай стандарты:**
- **STANDART_CODE.md**: 
  - Использование Java 24 features (Records для DTO, text blocks, pattern matching)
  - Следование архитектурным паттернам (layered architecture, API interface separation)
  - Использование MapStruct для маппинга
  - Правильная структура пакетов
  - Использование Lombok (@Slf4j, @RequiredArgsConstructor)
  - Bean Validation на DTO
  - Exception handling через GlobalExceptionHandler
  
- **STANDART_PROJECT.md**:
  - Использование @LoggableRequest для всех методов контроллера
  - Скрытие чувствительных полей в @LoggableRequest(hideFields = {...})
  - Использование исключений из common-lib (UniquenessValidationException, BusinessRuleValidationException, FormatValidationException)
  - Размещение shared DTOs в common-lib/dto
  - Размещение shared enums в common-lib/enums
  
- **STANDART_DOCKER.md**:
  - Multi-stage build (gradle:jdk24 для build stage, eclipse-temurin:24-jre для runtime stage)
  - Использование non-root user (appuser) для безопасности
  - Health checks в Dockerfile и docker-compose.yml
  - Правильный порядок копирования файлов для оптимизации кеширования слоев
  - JVM опции через ENV переменную JAVA_OPTS
  - .dockerignore для исключения ненужных файлов из build context
  - Правильная конфигурация docker-compose.yml (networks, volumes, depends_on с health conditions)
  - Использование конкретных версий образов (избегать latest)

**Компоненты для реализации на этом этапе:**
- Entity (если нужна новая или обновление существующей)
- Repository (если нужен новый или обновление существующего)
- Общие DTO (Filter, общие Response DTO, если используются несколькими эндпоинтами)
- Mapper интерфейс (MapStruct) - создание/обновление интерфейса, без методов для конкретных эндпоинтов
- Validator интерфейс - создание/обновление интерфейса, без методов для конкретных эндпоинтов
- Service интерфейс - создание/обновление интерфейса, без методов для конкретных эндпоинтов
- Конфиги (OpenApiConfig, если нужно обновить)
- Dockerfile (если создается новый сервис или требуется обновление согласно STANDART_DOCKER.md)
- .dockerignore (если создается новый сервис)
- docker-compose.yml (если добавляется новый сервис или изменяется конфигурация)

### 3. Реализация эндпоинтов (для каждого эндпоинта отдельно)

**Для каждого эндпоинта выполнить следующие шаги в указанном порядке:**

#### 3.1. DTO для эндпоинта
- Создать Request DTO (если нужен) - использовать Records
- Создать Response DTO (если нужен специфичный) - использовать Records
- Добавить Bean Validation аннотации
- Добавить @Schema аннотации для Swagger (на уровне класса и полей)

#### 3.2. Mapper методы для эндпоинта
- Добавить методы маппинга в Mapper интерфейс для данного эндпоинта
- Использовать @Mapping для специальных случаев
- Игнорировать служебные поля (id, timestamps, etc.)

#### 3.3. Validator методы для эндпоинта
- Добавить методы валидации в Validator интерфейс для данного эндпоинта
- Реализовать методы в ValidatorImpl
- Использовать исключения из common-lib

#### 3.4. Service методы для эндпоинта
- Добавить методы в Service интерфейс для данного эндпоинта
- Реализовать методы в ServiceImpl
- Использовать @Transactional где нужно
- Вызывать валидацию через Validator
- Использовать Mapper для преобразований

#### 3.5. Controller метод для эндпоинта
- Добавить метод в *Api интерфейс с OpenAPI аннотациями (@Operation, @ApiResponses, @Parameter)
- Добавить метод в Controller с @LoggableRequest
- Использовать @Valid для валидации
- Реализовать правильные HTTP статус-коды

#### 3.6. JavaDoc для эндпоинта
**Обязательно учитывай STANDART_JAVADOC.md:**
- Добавить JavaDoc для всех новых методов
- Обязательные теги: @author geron, @version 1.0
- @param для всех параметров
- @return для возвращаемых значений
- @throws для исключений
- JavaDoc для DTO Records с @param для всех компонентов
- Использовать @see для методов-реализаций интерфейсов

#### 3.7. Unit тесты для эндпоинта
**Обязательно учитывай STANDART_TEST.md:**

- Unit тесты для Service методов эндпоинта
- Unit тесты для Validator методов эндпоинта
- Unit тесты для Mapper методов эндпоинта (использовать реальный маппер, не мок)

**Требования к unit тестам:**
- Использовать @ExtendWith(MockitoExtension.class)
- Именование: `methodName_WhenCondition_ShouldExpectedResult`
- Использовать @Nested для группировки тестов
- Использовать AssertJ для assertions
- Следовать паттерну AAA (Arrange-Act-Assert)
- Проверять все успешные и ошибочные сценарии
- Проверять взаимодействия с зависимостями (verify)

#### 3.8. Integration тесты для эндпоинта
**Обязательно для всех новых эндпоинтов.**

- Тесты для эндпоинта контроллера
- Использовать @SpringBootTest, @AutoConfigureWebMvc
- Использовать MockMvc для тестирования REST endpoints
- Использовать WireMock для мокирования внешних сервисов (если есть интеграции)
- Использовать @Transactional для изоляции тестов
- Тестировать все возможные статус-коды (200, 201, 400, 404, 409)
- Проверять валидацию запросов
- Проверять формат ответов

#### 3.9. Swagger/OpenAPI документация для эндпоинта
**Обязательно для всех новых эндпоинтов.**
**Учитывай STANDART_SWAGGER.md:**

- Метод в *Api интерфейсе уже должен быть с @Operation и @ApiResponses (из шага 3.5)
- Убедиться, что все DTO имеют @Schema аннотации
- Добавить @ExampleObject для успешных и ошибочных ответов
- Использовать RFC 7807 Problem Details для ошибок

### 4. Финальная инфраструктура (только после реализации всех эндпоинтов)

#### 4.1. Обновление README
**Обязательно учитывай STANDART_README.md:**
- Обновить раздел "Основные возможности" (если добавлена новая функциональность)
- Обновить раздел "REST API":
  - Добавить все новые эндпоинты в таблицу
  - Добавить детальное описание всех новых эндпоинтов
- Обновить раздел "Бизнес-логика" (если добавлены новые методы сервиса)
- Обновить раздел "Слой валидации" (если добавлена новая валидация)
- Обновить раздел "Работа с базой данных" (если добавлены новые таблицы/поля)
- Обновить раздел "Примеры использования" (добавить примеры для всех новых эндпоинтов)
- **Все README файлы должны быть на русском языке**

#### 4.2. Postman коллекции
**Обязательно, если добавляются новые эндпоинты в контроллерах.**
**Учитывай STANDART_POSTMAN.md:**

- Добавить все новые запросы в коллекцию
- Именование запросов: lowercase с пробелами (например: "create user", "get user by id")
- Использовать переменную {{baseUrl}} для базового URL
- Использовать переменные окружения для path параметров ({{userId}}, {{tweetId}})
- Добавить описания для всех запросов
- Добавить примеры ответов для всех сценариев каждого эндпоинта:
  - Успешные ответы (200, 201)
  - Ошибки валидации (400)
  - Ресурс не найден (404)
  - Конфликты (409)
- Использовать правильный Content-Type:
  - `application/json` для успешных ответов
  - `application/problem+json` для ошибок
- Следовать RFC 7807 Problem Details для ошибок
- Обновить переменные окружения если нужно

#### 4.3. Проверка соответствия стандартам
- Проверить соответствие STANDART_CODE.md
- Проверить соответствие STANDART_PROJECT.md
- Проверить соответствие STANDART_TEST.md
- Проверить соответствие STANDART_JAVADOC.md
- Проверить соответствие STANDART_SWAGGER.md (если добавлены эндпоинты)
- Проверить соответствие STANDART_README.md
- Проверить соответствие STANDART_POSTMAN.md (если добавлены эндпоинты)
- Проверить соответствие STANDART_DOCKER.md (если создается новый сервис или изменяется Docker конфигурация)

#### 4.4. Проверка Docker конфигурации
**Обязательно, если создается новый сервис или изменяется Docker конфигурация.**
**Учитывай STANDART_DOCKER.md:**

- Проверить Dockerfile:
  - Multi-stage build структура (gradle:jdk24 для build, eclipse-temurin:24-jre для runtime)
  - Non-root user (appuser) создан и используется
  - Health check настроен правильно
  - Правильный порядок копирования файлов для кеширования
  - JVM опции через ENV переменную
  - Порт явно указан через EXPOSE
- Проверить .dockerignore:
  - Все ненужные файлы исключены (build/, .gradle/, IDE файлы, logs/, test файлы, etc.)
  - Файл создан в директории сервиса
- Проверить docker-compose.yml:
  - Правильная конфигурация build context и dockerfile пути
  - Health checks настроены для всех сервисов
  - Правильные depends_on с health conditions
  - Networks и volumes настроены корректно
  - Environment variables настроены правильно
  - Restart policy установлен (unless-stopped)

## Формат плана (TODO.md)

Сохрани результат в файл `todo/TODO.md` (или `todo/TODO_[название_задачи].md`).

Структурируй файл в виде чек-листа с разделением на "Done / In Progress / To Do" (по kanban-подходу).
Добавь приоритеты (P1, P2, P3).

### Шаблон TODO

**ВАЖНО:** Если задача включает несколько эндпоинтов, структурируй план следующим образом:
1. Анализ и проектирование
2. Реализация инфраструктуры и конфигов (один раз для всех эндпоинтов)
3. Для каждого эндпоинта отдельно: все слои от DTO до тестов
4. Финальная инфраструктура (README, Postman, проверка стандартов)

```markdown
# TODO: [Название задачи]

## Meta
- project: twitter-microservices
- updated: YYYY-MM-DD
- changelog: todo/CHANGELOG.md
- standards:
  - STANDART_CODE.md
  - STANDART_PROJECT.md
  - STANDART_TEST.md
  - STANDART_JAVADOC.md
  - STANDART_SWAGGER.md (если добавляются эндпоинты)
  - STANDART_README.md
  - STANDART_POSTMAN.md (если добавляются эндпоинты)
  - STANDART_DOCKER.md (если создается новый сервис или изменяется Docker конфигурация)

## Tasks

### Анализ и проектирование
- [ ] (P1) #1: Анализ требований — Краткое описание.
  acceptance: "Понять вход/выход, non-functional requirements, определить затронутые стандарты, определить список всех эндпоинтов"
- [ ] (P1) #2: Проектирование API и контрактов — Краткое описание.
  acceptance: "OpenAPI схема для всех эндпоинтов, DTO структура, Entity структура (если нужна), определение общих и специфичных компонентов"

### Реализация инфраструктуры и конфигов
- [ ] (P1) #3: Реализация Entity (если нужна) — Краткое описание.
  acceptance: "Entity создана/обновлена с учетом STANDART_CODE.md"
- [ ] (P1) #4: Реализация Repository — Краткое описание.
  acceptance: "Repository создан/обновлен с Derived Query Methods (без JavaDoc)"
- [ ] (P1) #5: Реализация общих DTO — Краткое описание.
  acceptance: "Общие DTO (Filter, общие Response) созданы как Records с валидацией, размещены в правильных пакетах"
- [ ] (P1) #6: Реализация Mapper интерфейса — Краткое описание.
  acceptance: "Mapper интерфейс создан/обновлен (без методов для конкретных эндпоинтов)"
- [ ] (P1) #7: Реализация Validator интерфейса — Краткое описание.
  acceptance: "Validator interface создан/обновлен (без методов для конкретных эндпоинтов)"
- [ ] (P1) #8: Реализация Service интерфейса — Краткое описание.
  acceptance: "Service interface создан/обновлен (без методов для конкретных эндпоинтов)"
- [ ] (P2) #9: Обновление конфигов — Краткое описание.
  acceptance: "OpenApiConfig обновлен если нужно (новые серверы, описание)"
- [ ] (P1) #10: Реализация Dockerfile — Краткое описание.
  acceptance: "Dockerfile создан/обновлен с учетом STANDART_DOCKER.md (multi-stage build, non-root user, health checks, правильный порядок копирования файлов)"
- [ ] (P1) #11: Реализация .dockerignore — Краткое описание.
  acceptance: ".dockerignore создан/обновлен с исключением всех ненужных файлов (build/, .gradle/, IDE файлы, logs/, test файлы)"
- [ ] (P2) #12: Обновление docker-compose.yml — Краткое описание.
  acceptance: "docker-compose.yml обновлен если нужно (новый сервис, health checks, depends_on с health conditions, networks, volumes)"

### Эндпоинт 1: [Название эндпоинта] (например: POST /api/v1/users)
- [ ] (P1) #13: DTO для эндпоинта 1 — Краткое описание.
  acceptance: "Request/Response DTO созданы как Records с валидацией и @Schema аннотациями"
- [ ] (P1) #14: Mapper методы для эндпоинта 1 — Краткое описание.
  acceptance: "Методы маппинга добавлены в Mapper интерфейс для эндпоинта 1"
- [ ] (P1) #15: Validator методы для эндпоинта 1 — Краткое описание.
  acceptance: "Методы валидации добавлены в Validator interface и implementation для эндпоинта 1"
- [ ] (P1) #16: Service методы для эндпоинта 1 — Краткое описание.
  acceptance: "Методы добавлены в Service interface и implementation для эндпоинта 1, используют @Transactional где нужно"
- [ ] (P1) #17: Controller метод для эндпоинта 1 — Краткое описание.
  acceptance: "Метод добавлен в *Api интерфейс с OpenAPI аннотациями и в Controller с @LoggableRequest"
- [ ] (P1) #18: JavaDoc для эндпоинта 1 — Краткое описание.
  acceptance: "JavaDoc добавлен для всех методов эндпоинта 1 с @author geron, @version 1.0"
- [ ] (P1) #19: Unit тесты для эндпоинта 1 — Краткое описание.
  acceptance: "Unit тесты для Service, Validator, Mapper методов эндпоинта 1 с учетом STANDART_TEST.md"
- [ ] (P2) #20: Integration тесты для эндпоинта 1 — Краткое описание.
  acceptance: "Integration тесты для эндпоинта 1 с MockMvc, все статус-коды проверены"
- [ ] (P1) #21: Swagger документация для эндпоинта 1 — Краткое описание.
  acceptance: "OpenAPI документация для эндпоинта 1 полная с @ExampleObject для всех сценариев"

### Эндпоинт 2: [Название эндпоинта] (например: GET /api/v1/users/{id})
- [ ] (P1) #22: DTO для эндпоинта 2 — Краткое описание.
  acceptance: "Request/Response DTO созданы как Records с валидацией и @Schema аннотациями"
- [ ] (P1) #23: Mapper методы для эндпоинта 2 — Краткое описание.
  acceptance: "Методы маппинга добавлены в Mapper интерфейс для эндпоинта 2"
- [ ] (P1) #24: Validator методы для эндпоинта 2 — Краткое описание.
  acceptance: "Методы валидации добавлены в Validator interface и implementation для эндпоинта 2"
- [ ] (P1) #25: Service методы для эндпоинта 2 — Краткое описание.
  acceptance: "Методы добавлены в Service interface и implementation для эндпоинта 2, используют @Transactional где нужно"
- [ ] (P1) #26: Controller метод для эндпоинта 2 — Краткое описание.
  acceptance: "Метод добавлен в *Api интерфейс с OpenAPI аннотациями и в Controller с @LoggableRequest"
- [ ] (P1) #27: JavaDoc для эндпоинта 2 — Краткое описание.
  acceptance: "JavaDoc добавлен для всех методов эндпоинта 2 с @author geron, @version 1.0"
- [ ] (P1) #28: Unit тесты для эндпоинта 2 — Краткое описание.
  acceptance: "Unit тесты для Service, Validator, Mapper методов эндпоинта 2 с учетом STANDART_TEST.md"
- [ ] (P2) #29: Integration тесты для эндпоинта 2 — Краткое описание.
  acceptance: "Integration тесты для эндпоинта 2 с MockMvc, все статус-коды проверены"
- [ ] (P1) #30: Swagger документация для эндпоинта 2 — Краткое описание.
  acceptance: "OpenAPI документация для эндпоинта 2 полная с @ExampleObject для всех сценариев"

### ... (повторить для каждого следующего эндпоинта)

### Финальная инфраструктура
- [ ] (P2) #N: Обновление README.md — Краткое описание.
  acceptance: "README обновлен с учетом STANDART_README.md, все новые эндпоинты документированы"
- [ ] (P2) #N+1: Обновление Postman коллекции — Краткое описание.
  acceptance: "Добавлены все новые запросы с примерами ответов для всех эндпоинтов, обновлены переменные окружения"
- [ ] (P1) #N+2: Проверка соответствия стандартам — Краткое описание.
  acceptance: "Все стандарты проверены, код соответствует требованиям"
- [ ] (P1) #N+3: Проверка Docker конфигурации — Краткое описание.
  acceptance: "Dockerfile, .dockerignore и docker-compose.yml проверены на соответствие STANDART_DOCKER.md (multi-stage build, non-root user, health checks, правильная структура)"

## Assumptions
- Список принятых предположений
- Например: "Предполагается, что пользователь уже существует при создании твита"

## Risks
- Технические риски
- Организационные риски
- Зависимости от других сервисов/компонентов

## Metrics & Success Criteria
- Метрики для оценки успешности реализации
- Критерии приемки
- Например: "Все тесты проходят, покрытие кода > 80%"

## Notes
- Примечания и ссылки
- Ссылки на стандарты
- Ссылки на связанные задачи
```

## При формировании плана обязательно

1. **Разбивай план по эндпоинтам, а не только по слоям:**
   - Если задача включает несколько эндпоинтов, структурируй план так:
     * Сначала - общая инфраструктура (Entity, Repository, общие DTO, интерфейсы)
     * Затем - для каждого эндпоинта отдельно: DTO → Mapper → Validator → Service → Controller → JavaDoc → Unit тесты → Integration тесты → Swagger
     * В конце - финальная инфраструктура (README, Postman, проверка стандартов)
   - Это позволяет реализовывать эндпоинты последовательно и независимо
   - Каждый эндпоинт можно реализовать полностью от начала до конца перед переходом к следующему

2. **Думай как архитектор, тимлид и DevOps одновременно:**
   - Учитывай масштабируемость решения
   - Продумывай интеграции между сервисами
   - Учитывай производительность и безопасность

3. **Предусмотри как технические, так и организационные риски:**
   - Технические: зависимости, производительность, безопасность
   - Организационные: сроки, ресурсы, знания команды

4. **Отрази, какие метрики и критерии успешности будут использоваться:**
   - Покрытие тестами
   - Соответствие стандартам
   - Производительность (если применимо)
   - Качество кода

5. **Заложи шаги на ретроспективу и улучшение процессов:**
   - Анализ проделанной работы
   - Выявление улучшений
   - Обновление документации при необходимости

6. **Учитывай все стандарты проекта:**
   - Всегда проверяй соответствие кода стандартам
   - Документируй согласно стандартам
   - Тестируй согласно стандартам
   - Обновляй документацию согласно стандартам

## Важные напоминания

- **Не пиши код на этапе планирования** - только анализ и план
- **Разбивай план по эндпоинтам** - если задача включает несколько эндпоинтов, структурируй план так:
  - Сначала общая инфраструктура (Entity, Repository, интерфейсы)
  - Затем для каждого эндпоинта отдельно: все слои от DTO до тестов
  - В конце финальная инфраструктура (README, Postman, проверка стандартов)
- **Всегда учитывай стандарты проекта** - они обязательны для соблюдения
- **Если создается новый сервис или изменяется Docker конфигурация** - обязательно:
  - Dockerfile с multi-stage build, non-root user, health checks
  - .dockerignore для исключения ненужных файлов
  - Обновление docker-compose.yml с правильной конфигурацией
  - Проверка соответствия STANDART_DOCKER.md
- **Если добавляются новые эндпоинты** - обязательно:
  - Integration тесты
  - Swagger документация
  - Postman коллекции
- **Все README на русском языке**
- **Все JavaDoc на английском языке**
- **Все Swagger документация на английском языке**

